"""Swap two quantum memories inside a MemoryArray of a node
   Used in companion with the Adaptive Continuous protocol
"""

from typing import TYPE_CHECKING, List, Dict, Any, Tuple
from enum import Enum, auto

from sequence.message import Message
from sequence.entanglement_management.entanglement_protocol import EntanglementProtocol
from sequence.components.memory import Memory
from sequence.resource_management.memory_manager import MemoryInfo, MemoryManager
from sequence.utils import log
from sequence.kernel.process import Process
from sequence.kernel.event import Event


if TYPE_CHECKING:
    from adaptive_continuous import AdaptiveContinuousProtocol
    from sequence.topology.node import Node
    from sequence.message import Message


class SwapMemoryMsgType(Enum):
    '''Defines possible message types for swap message protocol
    '''
    INFORM_EP = auto()


class SwapMemoryMessage(Message):
    '''Message used by swap message protocol

    Attributes:
        msg_type (SwapMemoryMsgType)
        receiver (str)
        entanglement_pair (tuple)
    '''
    def __init__(self, msg_type: SwapMemoryMsgType, receiver: str, entanglement_pair: tuple):
        super().__init__(msg_type, receiver)
        self.entanglement_pair = entanglement_pair

    def __str__(self):
        return f'type={self.msg_type}; receiver={self.receiver}; entanglement pair={self.entanglement_pair}'


class SwapMemoryProtocol(EntanglementProtocol):
    '''Swap two memories:
        1) one is from an entangled pair generated by the adaptive continuous protocol
        2) the other is a RAW memory
    
        Attributes:
            owner (Node): node protocol is attached to
            name (str): name of the protocl instance
            memory (Memory): RAW memory to entangle
            entanglement_pair (tuple): the entanglement pair pre-generated by the adaptive continuous protocol
            entangled_memory (Memory) entangled memory from the entanglement pair
            rule (Rule): Rule which created this protocol instance (from the rule manager)
            scheduled_events (List): events scheduled
    '''

    def __init__(self, owner: "Node", name: str, remote_node_name: str, memory: Memory):
        '''
        Args:
            Owner -- node protocol is attached to
            name -- name of the protocl instance
        '''
        super().__init__(owner, name)
        self.memory = memory
        self.memories: List[Memory] = [memory]
        self.entanglement_pair = None
        self.entangled_memory = None
        self.scheduled_events = []
        self.primary = False
        # remote
        self.remote_node_name = remote_node_name
        self.remote_memory_name = None
        self.remote_protocol_name = None


    def set_entanglement_pair(self, entanglement_pair: tuple):
        self.entanglement_pair = entanglement_pair


    def received_message(self, src: str, msg: Message):
        '''override parent method
        '''
        log.logger.debug(f'{self.owner.name} received message {msg} from {src}')

        msg_type = msg.msg_type
        if msg_type is SwapMemoryMsgType.INFORM_EP:
            adaptive_continuous = self.get_adaptive_continuous_protocol()
            try:
                entangled_memory_name = self.get_entanglement_memory_name(msg.entanglement_pair)
                adaptive_continuous.remove_entanglement_pair(msg.entanglement_pair)
                self.swap_two_memory(self.memory.name, entangled_memory_name)
            except Exception as e:
                log.logger.warning(f'{self.owner.name} Swap memory failed between {self.memory.name} and {entangled_memory_name}! Error message: {e}. ' + 
                                    'Likely due to expire event from AC protocol happened in the middle of a Swap Memory Protocol.')
                self.update_resource_manager(self.memory, MemoryInfo.RAW)
        else:
            raise Exception(f'msg_type {msg_type} unknown')


    def get_adaptive_continuous_protocol(self) -> "AdaptiveContinuousProtocol":
        '''get the adaptive continuous protocol via self.owners
        '''
        return self.owner.adaptive_continuous


    def set_others(self, protocol_name: str, node: str, memory_names: List[str]) -> "Node":
        '''override parent abstract method
        '''
        assert self.remote_protocol_name is None
        self.remote_protocol_name = protocol_name
        self.remote_memory_name = memory_names[0]


    def start(self) -> None:
        '''override parent abstract method. start the swap memory protocol

        Side Effects:
            Will send message through attached node
        '''
        log.logger.debug(f'{self.owner.name} protocol start with partner {self.remote_node_name}')

        if self.primary:
            entangled_memory_name = self.get_entanglement_memory_name(self.entanglement_pair)

            # send a message to the non-primary node to inform the selected entanglement pair
            msg = SwapMemoryMessage(SwapMemoryMsgType.INFORM_EP, self.remote_protocol_name, self.entanglement_pair)
            self.owner.send_message(self.remote_node_name, msg)

            # swap the memory at a future time
            classical_delay = self.owner.cchannels[self.remote_node_name].delay
            future_swap_time = self.owner.timeline.now() + classical_delay
            occupied_memory_name = self.memory.name
            process = Process(self, 'swap_two_memory', [occupied_memory_name, entangled_memory_name])
            event = Event(future_swap_time, process)
            self.owner.timeline.schedule(event)
            self.scheduled_events.append(event)


    def get_entanglement_memory_name(self, entanglement_pair: tuple) -> str:
        '''Given the entanglement_pair, return the entangled_memory to swap with self.memory
        Args:
            entantlement_pair: ((node_name, entangled_memory_name), (node_name, entangled_memory_name)), all names are str
        '''
        for node_name, memory_name in entanglement_pair:
            if node_name == self.owner.name:
                entangled_memory_name = memory_name
                return entangled_memory_name
        else:
            raise Exception(f'{self.owner.name} not in {entanglement_pair}')


    def check_entangled_memory(self, entangled_memory_name: str) -> bool:
        '''check if the parameter entangled_memory_name is indeed in an entangled state
           useful when the AC protocol's expire event interrupted the swapping protocol process (which takes 2 ms long)
        
        Args:
            entanlged_memory_name: name of the memory that is in entangled state
        Return:
            True if the memory is indeed entangled, otherwise False
        '''
        return self.owner.resource_manager.check_entangled_memory(entangled_memory_name)


    def swap_two_memory(self, occupied_memory_name: str, entangled_memory_name: str):
        '''swap memory between self.memory and the memory that entangle_memory_name is referring to
        Args:
            occupied_memory_name:  the name of the occupied memory (by the entanglement generation protocol)
            entangled_memory_name: the name of the entangled memory (generated by the adaptive continuous protocol) on this node
        '''
        if self.check_entangled_memory(entangled_memory_name) is False:
            log.logger.info(f'{self.owner.name} Swap memory failed between {occupied_memory_name} and {entangled_memory_name}!')
            self.update_resource_manager(self.memory, MemoryInfo.RAW)
            return

        log.logger.info(f'{self.owner.name} Swap memory between {occupied_memory_name} and {entangled_memory_name}')
        self.owner.resource_manager.swap_two_memory(occupied_memory_name, entangled_memory_name) # the memory_array is updated, but more needs to update

        memory_manager = self.get_memory_manager()
        memory_array = memory_manager.get_memory_array()
        # after swapping, the entanged memory turns into occupied memory, while the occupied memory turns into entangled memory
        entangled_memory = memory_array.get_memory_by_name(occupied_memory_name)
        occupied_memory  = memory_array.get_memory_by_name(entangled_memory_name)

        # update self.memory (the current entangled memory)
        self.memory = entangled_memory
        self.memories = [self.memory]
        self.memory.entangled_memory['memo_id'] = self.remote_memory_name
        mem_info = memory_manager.get_info_by_memory(entangled_memory)
        mem_info.remote_memo = self.remote_memory_name
        self.update_resource_manager_swap_memory(self, self.memory, MemoryInfo.ENTANGLED)

        # update the current occupied memory to RAW
        mem_info = memory_manager.get_info_by_memory(occupied_memory)
        mem_info.to_raw()
        self.update_resource_manager_swap_memory(None, occupied_memory, MemoryInfo.RAW)


    def update_resource_manager_swap_memory(self, protocol, memory, state):
        '''update the resource manager when using the swap memory
        1) add argument protocol
        2) use resource_manager.update_swap_memory()
        '''
        self.owner.resource_manager.update_swap_memory(protocol, memory, state)


    def get_memory_manager(self) -> MemoryManager:
        '''get the memory manager that is associated to self.owner
        '''
        return self.owner.resource_manager.memory_manager


    def is_ready(self) -> bool:
        '''override parent abstract method. check if protocol is ready to start

        Return:
            bool: if protocol is ready or not
        '''
        return self.remote_protocol_name is not None
    

    def memory_expire(self, memory: "Memory") -> None:
        '''override parent abstract method. method to receive expired memories
        '''

        assert memory == self.memory

        self.update_resource_manager(memory, MemoryInfo.RAW)
        for event in self.scheduled_events:
            if event.time >= self.owner.timeline.now():
                self.owner.timeline.remove_event(event)



# swap memory

def swapmem_rule_action1(memories_info: List["MemoryInfo"], args: Dict[str, Any]) -> Tuple[SwapMemoryProtocol, List[None], List[None], List[None]]:
    """Action function used by swap memory protocol on nodes except the initiator, i.e., index > 0
    """
    entanglement_pair = args['entanglement_pair']
    memories = [info.memory for info in memories_info]
    memory = memories[0]
    protocol_name = f'SWAPMEM.{memory.name}'
    path = args['path']
    index = args['index']
    other_node = path[index - 1]
    protocol = SwapMemoryProtocol(None, protocol_name, other_node, memory)
    protocol.entanglement_pair = entanglement_pair
    protocol.primary = True
    return protocol, [None], [None], [None]


def swapmem_rule_action2(memories_info: List["MemoryInfo"], args: Dict[str, Any]) -> Tuple[SwapMemoryProtocol, List[None], List[None], List[None]]:
    """Action function used by swap memory protocol on nodes except the responder, i.e., index < len(path) - 1
    """
    memories = [info.memory for info in memories_info]
    memory = memories[0]
    path = args['path']
    index = args['index']
    other_node = path[index + 1]
    req_args = {'name': args['name'], 'reservation': args['reservation']}
    protocol_name = f'SWAPMEM.{memory.name}'
    protocol = SwapMemoryProtocol(None, protocol_name, other_node, memory)
    return protocol, [other_node],[swapmem_req_func], [req_args]


def swapmem_req_func(protocols: List["EntanglementProtocol"], args: Dict[str, Any]) -> SwapMemoryProtocol:
    '''Function used by `smem_rule_action2` function for selecting swap memory protocols on the remote node
    Args:
        protocols: the waiting protocols (wait for request)
        args: arguments from the node who sent the request
    Return:
        the selected protocol
    '''
    name = args['name']
    reservation = args['reservation']
    for protocol in protocols:
        if isinstance(protocol, SwapMemoryProtocol) and protocol.remote_node_name == name \
                and protocol.rule.get_reservation() == reservation:
            return protocol

# no need for a 'smem_rule_condition' function, because the condition is in RuleAdaptive.do()
